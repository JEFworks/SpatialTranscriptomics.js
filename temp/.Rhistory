## center data myself (make mean 0)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
library(RSpectra)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 20,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
pca
tail(pca$u, 1)
tail(pca$v, 1)
pca$u[,1]
pca$u[1,]
pca$u[0,]
pca$u[1,]
pca$v[1,]
pca$u[1,]
######## read in data
dir <- 'filtered_feature_bc_matrix/filtered/'
cd <- readMM(paste0(dir, 'filtered_matrix.mtx.gz'))
genes <- read.csv(paste0(dir, 'filtered_features.tsv.gz'), sep='\t', header=FALSE)
cells <- read.csv(paste0(dir, 'barcodes.tsv.gz'), sep='\t', header=FALSE)
head(genes)
head(cells)
rownames(cd) <- genes[,2]
colnames(cd) <- cells[,1]
head(cd)
######### QC
dev.off()
par(mfrow=c(2,2))
x= log10(rowSums(cd)+1)
y=log10(colSums(cd>0)+1)
hist(x, breaks=5) ## distribution of cells per gene (log scale)
hist(y, breaks=12) ## distribution of unique gene species per cell ie. library complexity (log scale)
vi <- log10(rowSums(cd) + 1) >= 3.5 ## pick a filtering threshold
cd.filter <- cd[vi,]
vi <- log10(colSums(cd > 0) + 1) >= 1.0 ## pick a filtering threshold
cd.filter <- cd.filter[,vi]
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
mat <- log10(mat + 1)
dim(mat)
## Principal components dimensionality reduction
## the built in PCA is too slow but feel free to try
# pcs <- prcomp(mat)
## we will instead install a faster implementation
#install.packages("RSpectra")
## center data myself (make mean 0)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
library(RSpectra)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 20,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
pca
pca$u[1,]
dim(mat)
vi <- log10(rowSums(cd) + 1) >= 4 ## pick a filtering threshold
cd.filter <- cd[vi,]
vi <- log10(colSums(cd > 0) + 1) >= 1.0 ## pick a filtering threshold
cd.filter <- cd.filter[,vi]
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
mat <- log10(mat + 1)
dim(mat)
## Principal components dimensionality reduction
## the built in PCA is too slow but feel free to try
# pcs <- prcomp(mat)
## we will instead install a faster implementation
#install.packages("RSpectra")
## center data myself (make mean 0)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
dim(mat)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 20,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 19,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
pca
pca$u[1,]
pca$v[1,]
mat
mat[1,1]
mat[1:2,1:2]
tail(mat[,1:2])
tail(mat[,1:2], 1)
tail(mat[,1:20], 1)
######## read in data
dir <- 'filtered_feature_bc_matrix/filtered/'
cd <- readMM(paste0(dir, 'filtered_matrix.mtx.gz'))
genes <- read.csv(paste0(dir, 'filtered_features.tsv.gz'), sep='\t', header=FALSE)
cells <- read.csv(paste0(dir, 'barcodes.tsv.gz'), sep='\t', header=FALSE)
head(genes)
head(cells)
rownames(cd) <- genes[,2]
colnames(cd) <- cells[,1]
head(cd)
######### QC
dev.off()
par(mfrow=c(2,2))
x= log10(rowSums(cd)+1)
y=log10(colSums(cd>0)+1)
hist(x, breaks=5) ## distribution of cells per gene (log scale)
hist(y, breaks=12) ## distribution of unique gene species per cell ie. library complexity (log scale)
vi <- log10(rowSums(cd) + 1) >= 3.5 ## pick a filtering threshold
cd.filter <- cd[vi,]
vi <- log10(colSums(cd > 0) + 1) >= 1.0 ## pick a filtering threshold
cd.filter <- cd.filter[,vi]
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
mat <- log10(mat + 1)
dim(mat)
## Principal components dimensionality reduction
## the built in PCA is too slow but feel free to try
# pcs <- prcomp(mat)
## we will instead install a faster implementation
#install.packages("RSpectra")
## center data myself (make mean 0)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
library(RSpectra)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 19,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
pca
pca$u[1,]
############# PCA plots
par(mfrow=c(2,2), mar=rep(4,4))
## look at elbow plot to check what is reasonable number of pcs
val <- pca$d
plot(val, type="l")
points(val)
N <- 10
abline(v=N, col='red')
pcs <- pca$u[, 1:N]
rownames(pcs) <- colnames(mat)
colnames(pcs) <- paste0('PC', 1:N)
head(pcs)
plotEmbedding(pcs[,1:2], main='PC1 and PC2')
g <- 'Camk2n1'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
g <- 'Agt'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
# mat <- log10(mat + 1)
dim(mat)
## Principal components dimensionality reduction
## the built in PCA is too slow but feel free to try
# pcs <- prcomp(mat)
## we will instead install a faster implementation
#install.packages("RSpectra")
library(RSpectra)
pca <- RSpectra::svds(
A    = t(mat),
k    = 20,
opts = list(
center = TRUE, scale = TRUE, maxitr = 2000, tol = 1e-10
)
)
# ## Scale and center data myself
# m <- t(mat)
# m <- t(t(m) - colMeans(m))
# colMeans(m) ## double check mean is ~0
# m <- scale(m)
# apply(m, 2, var) ## double check var is 1
# pca <- RSpectra::svds(
#   A    = m,
#   k    = 20,
#   opts = list(
#     center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
#   )
# )
## look at elbow plot to check what is reasonable number of pcs
val <- pca$d
plot(val, type="l")
points(val)
N <- 10
abline(v=N, col='red')
pcs <- pca$u[, 1:N]
rownames(pcs) <- colnames(mat)
colnames(pcs) <- paste0('PC', 1:N)
head(pcs)
############# PCA plots
par(mfrow=c(2,2), mar=rep(4,4))
#MUDAN::plotEmbedding(pcs[,1:2], main='PC1 and PC2')
g <- 'Nptxr'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
MUDAN::plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
g <- 'Agt'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
MUDAN::plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
######## read in data
dir <- 'filtered_feature_bc_matrix/filtered/'
cd <- readMM(paste0(dir, 'filtered_matrix.mtx.gz'))
genes <- read.csv(paste0(dir, 'filtered_features.tsv.gz'), sep='\t', header=FALSE)
cells <- read.csv(paste0(dir, 'barcodes.tsv.gz'), sep='\t', header=FALSE)
head(genes)
head(cells)
rownames(cd) <- genes[,2]
colnames(cd) <- cells[,1]
head(cd)
######### QC
dev.off()
par(mfrow=c(2,2))
x= log10(rowSums(cd)+1)
y=log10(colSums(cd>0)+1)
hist(x, breaks=5) ## distribution of cells per gene (log scale)
hist(y, breaks=12) ## distribution of unique gene species per cell ie. library complexity (log scale)
vi <- log10(rowSums(cd) + 1) >= 3.5 ## pick a filtering threshold
cd.filter <- cd[vi,]
vi <- log10(colSums(cd > 0) + 1) >= 1.0 ## pick a filtering threshold
cd.filter <- cd.filter[,vi]
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
# mat <- log10(mat + 1)
dim(mat)
## Principal components dimensionality reduction
## the built in PCA is too slow but feel free to try
# pcs <- prcomp(mat)
## we will instead install a faster implementation
#install.packages("RSpectra")
## center data myself (make mean 0)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
library(RSpectra)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 20,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
############# PCA plots
par(mfrow=c(2,2), mar=rep(4,4))
## look at elbow plot to check what is reasonable number of pcs
val <- pca$d
plot(val, type="l")
points(val)
N <- 10
abline(v=N, col='red')
pcs <- pca$u[, 1:N]
rownames(pcs) <- colnames(mat)
colnames(pcs) <- paste0('PC', 1:N)
head(pcs)
plotEmbedding(pcs[,1:2], main='PC1 and PC2')
g <- 'Agt'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
g <- 'Cam2kn1'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
g <- 'Nptxr'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
### SPATIAL
spotPos <- read.csv("spatial/tissue_positions_list.csv", header=FALSE)
rownames(spotPos) <- spotPos$V1
tissueSpots <- intersect(spotPos[,1], barcodes[,1])
tissueSpotPos <- spotPos[tissueSpots,c("V5", "V6")] # spot IDs and their positions
tissueSpotPosFilt <- tissueSpotPos[colnames(cd.filter),]
tissue_hires_scalef <- 0.17011142
tissueSpotPosFiltAdj <- tissueSpotPosFilt
tissueSpotPosFiltAdj$V5 <- tissueSpotPosFilt$V5 * tissue_hires_scalef
tissueSpotPosFiltAdj$V6 <- tissueSpotPosFilt$V6 * tissue_hires_scalef
tissueSpotRotation <- tissueSpotPosFiltAdj[c("V6", "V5")]
tissueSpotRotation$V5 <- tissueSpotRotation$V5 * -1
plotEmbedding(tissueSpotRotation, col=gexp,
cex=1, xlab=NA, ylab=NA,
verbose=FALSE)
tissueSpotRotation <- tissueSpotPosFiltAdj[c("V6", "V5")]
spotPos <- read.csv("spatial/tissue_positions_list.csv", header=FALSE)
barcodes <- read.csv("filtered_feature_bc_matrix/barcodes.tsv.gz", header=FALSE)
rownames(spotPos) <- spotPos$V1
tissueSpots <- intersect(spotPos[,1], barcodes[,1])
tissueSpotPos <- spotPos[tissueSpots,c("V5", "V6")] # spot IDs and their positions
tissueSpotPosFilt <- tissueSpotPos[colnames(cd.filter),]
tissue_hires_scalef <- 0.17011142
tissueSpotPosFiltAdj <- tissueSpotPosFilt
tissueSpotPosFiltAdj$V5 <- tissueSpotPosFilt$V5 * tissue_hires_scalef
tissueSpotPosFiltAdj$V6 <- tissueSpotPosFilt$V6 * tissue_hires_scalef
tissueSpotRotation <- tissueSpotPosFiltAdj[c("V6", "V5")]
tissueSpotRotation$V5 <- tissueSpotRotation$V5 * -1
plotEmbedding(tissueSpotRotation, col=gexp,
cex=1, xlab=NA, ylab=NA,
verbose=FALSE)
g <- 'Agt'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
spotPos <- read.csv("spatial/tissue_positions_list.csv", header=FALSE)
barcodes <- read.csv("filtered_feature_bc_matrix/barcodes.tsv.gz", header=FALSE)
rownames(spotPos) <- spotPos$V1
tissueSpots <- intersect(spotPos[,1], barcodes[,1])
tissueSpotPos <- spotPos[tissueSpots,c("V5", "V6")] # spot IDs and their positions
tissueSpotPosFilt <- tissueSpotPos[colnames(cd.filter),]
tissue_hires_scalef <- 0.17011142
tissueSpotPosFiltAdj <- tissueSpotPosFilt
tissueSpotPosFiltAdj$V5 <- tissueSpotPosFilt$V5 * tissue_hires_scalef
tissueSpotPosFiltAdj$V6 <- tissueSpotPosFilt$V6 * tissue_hires_scalef
tissueSpotRotation <- tissueSpotPosFiltAdj[c("V6", "V5")]
tissueSpotRotation$V5 <- tissueSpotRotation$V5 * -1
plotEmbedding(tissueSpotRotation, col=gexp,
cex=1, xlab=NA, ylab=NA,
verbose=FALSE)
gexp
scale()
######## read in data
dir <- 'filtered_feature_bc_matrix/filtered/'
cd <- readMM(paste0(dir, 'filtered_matrix.mtx.gz'))
genes <- read.csv(paste0(dir, 'filtered_features.tsv.gz'), sep='\t', header=FALSE)
cells <- read.csv(paste0(dir, 'barcodes.tsv.gz'), sep='\t', header=FALSE)
head(genes)
head(cells)
rownames(cd) <- genes[,2]
colnames(cd) <- cells[,1]
head(cd)
dev.off()
par(mfrow=c(2,2))
x= log10(rowSums(cd)+1)
y=log10(colSums(cd>0)+1)
hist(x, breaks=5) ## distribution of cells per gene (log scale)
hist(y, breaks=12) ## distribution of unique gene species per cell ie. library complexity (log scale)
vi <- log10(rowSums(cd) + 1) >= 3.5 ## pick a filtering threshold
cd.filter <- cd[vi,]
vi <- log10(colSums(cd > 0) + 1) >= 1.0 ## pick a filtering threshold
cd.filter <- cd.filter[,vi]
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
mat <- log10(mat + 1)
dim(mat)
## center data myself (make mean 0)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
library(RSpectra)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 20,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
############# PCA plots
par(mfrow=c(2,2), mar=rep(4,4))
## look at elbow plot to check what is reasonable number of pcs
val <- pca$d
plot(val, type="l")
points(val)
N <- 10
abline(v=N, col='red')
pcs <- pca$u[, 1:N]
rownames(pcs) <- colnames(mat)
colnames(pcs) <- paste0('PC', 1:N)
head(pcs)
plotEmbedding(pcs[,1:2], main='PC1 and PC2')
g <- 'Nptxr'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
############# 2D visualization
## TSNE embedding with regular PCs
## Can also use UMAP (try it out for yourself) using the uwot package
library(Rtsne)
emb <- Rtsne::Rtsne(pcs,
is_distance=FALSE,
perplexity=30,
max_iter=500,
num_threads=1,
verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)
plotEmbedding(emb, col = gexp, main='tSNE', xlab = "t-SNE X", ylab = "t-SNE Y")
### SPATIAL
g <- 'Nptxr'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
spotPos <- read.csv("spatial/tissue_positions_list.csv", header=FALSE)
barcodes <- read.csv("filtered_feature_bc_matrix/barcodes.tsv.gz", header=FALSE)
rownames(spotPos) <- spotPos$V1
tissueSpots <- intersect(spotPos[,1], barcodes[,1])
tissueSpotPos <- spotPos[tissueSpots,c("V5", "V6")] # spot IDs and their positions
tissueSpotPosFilt <- tissueSpotPos[colnames(cd.filter),]
tissue_hires_scalef <- 0.17011142
tissueSpotPosFiltAdj <- tissueSpotPosFilt
tissueSpotPosFiltAdj$V5 <- tissueSpotPosFilt$V5 * tissue_hires_scalef
tissueSpotPosFiltAdj$V6 <- tissueSpotPosFilt$V6 * tissue_hires_scalef
tissueSpotRotation <- tissueSpotPosFiltAdj[c("V6", "V5")]
tissueSpotRotation$V5 <- tissueSpotRotation$V5 * -1
plotEmbedding(tissueSpotRotation, col=gexp,
cex=1, xlab=NA, ylab=NA,
verbose=FALSE)
######## Counts per million (CPM) normalization
mat <- Matrix::t(Matrix::t(cd.filter)/Matrix::colSums(cd.filter))
mat <- mat * 1e6
# mat <- log10(mat + 1)
dim(mat)
m <- t(mat) # cells x genes
m <- t(m) - colMeans(m) # now, m is genes x cells - mean(genes)
library(RSpectra)
pca <- RSpectra::svds(
A    = t(m), # cells x genes
k    = 20,
opts = list(
center = FALSE, scale = FALSE, maxitr = 2000, tol = 1e-10
)
)
par(mfrow=c(2,2), mar=rep(4,4))
## look at elbow plot to check what is reasonable number of pcs
val <- pca$d
plot(val, type="l")
points(val)
N <- 10
abline(v=N, col='red')
pcs <- pca$u[, 1:N]
rownames(pcs) <- colnames(mat)
colnames(pcs) <- paste0('PC', 1:N)
head(pcs)
plotEmbedding(pcs[,1:2], main='PC1 and PC2')
g <- 'Nptxr'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
plotEmbedding(pcs[,1:2], main=g, col=gexp,
xlab='PC1', ylab='PC2')
############# 2D visualization
## TSNE embedding with regular PCs
## Can also use UMAP (try it out for yourself) using the uwot package
library(Rtsne)
emb <- Rtsne::Rtsne(pcs,
is_distance=FALSE,
perplexity=30,
max_iter=500,
num_threads=1,
verbose=FALSE)$Y
rownames(emb) <- rownames(pcs)
plotEmbedding(emb, col = gexp, main='tSNE', xlab = "t-SNE X", ylab = "t-SNE Y")
### SPATIAL
g <- 'Nptxr'
gexp <- scale(mat[g,])[,1]
gexp[gexp > 1.5] <- 1.5
gexp[gexp < -1.5] <- -1.5
spotPos <- read.csv("spatial/tissue_positions_list.csv", header=FALSE)
barcodes <- read.csv("filtered_feature_bc_matrix/barcodes.tsv.gz", header=FALSE)
rownames(spotPos) <- spotPos$V1
tissueSpots <- intersect(spotPos[,1], barcodes[,1])
tissueSpotPos <- spotPos[tissueSpots,c("V5", "V6")] # spot IDs and their positions
tissueSpotPosFilt <- tissueSpotPos[colnames(cd.filter),]
tissue_hires_scalef <- 0.17011142
tissueSpotPosFiltAdj <- tissueSpotPosFilt
tissueSpotPosFiltAdj$V5 <- tissueSpotPosFilt$V5 * tissue_hires_scalef
tissueSpotPosFiltAdj$V6 <- tissueSpotPosFilt$V6 * tissue_hires_scalef
tissueSpotRotation <- tissueSpotPosFiltAdj[c("V6", "V5")]
tissueSpotRotation$V5 <- tissueSpotRotation$V5 * -1
plotEmbedding(tissueSpotRotation, col=gexp,
cex=1, xlab=NA, ylab=NA,
verbose=FALSE)
colSums(mat)
hist(mat[1])
hist(mat[1,])
hist(log10(mat[1,]+1))
